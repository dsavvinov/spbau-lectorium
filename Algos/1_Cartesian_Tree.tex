\documentclass[fleqn, 12pt]{article}
\usepackage[left=0.5in, right=0.5in, top=1in, bottom=0.5in]{geometry}
\usepackage{mathexam}
\usepackage{mathtext} 				% русские буквы в фомулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{enumerate}
\usepackage{tabularx}
%%% Дополнительная работа с математикой
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools,amsthm}
\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{enumitem}
\usepackage{indentfirst}
\relpenalty=9999
\binoppenalty=9999
\newcommand{\bigslant}[2]{{\raisebox{.2em}{$#1$}\left/\raisebox{-.2em}{$#2$}\right.}}
%чудоскобки
\newcommand{\lr}[1]{\left({#1}\right)}
\newcommand{\lrl}[1]{\left\{{#1}\right\}} 
\newcommand{\lrh}[1]{\left[{#1}\right]}
%мелкие полезности
\newcommand{\eps}{\varepsilon} 
\newcommand{\ar}{\ \ \Leftrightarrow \ \ }
\newcommand{\arr}{\ \Rightarrow \ }
\newcommand{\arl}{\ \Leftarrow \ }
%многострочная формула с выравниванием по амперсантам
\newcommand{\Split}[1]{%
	\begin{equation}
	\begin{split}
	#1
	\notag
	\end{split}
	\end{equation}
}
%системы уравнений
\newcommand{\dand}[2]{\left\{\begin{aligned}&#1\\&#2\\\end{aligned}\right.}
\newcommand{\dor}[2]{\left[\begin{aligned}&#1\\&#2\\\end{aligned}\right.}
\newcommand{\ans}[1]{\left\{\begin{aligned}#1\end{aligned}\right.}
\newcommand{\ors}[1]{\left[\begin{aligned}#1\end{aligned}\right.}	
\newcommand{\bigo}{\mathcal{O}}
\newcommand{\mb}[1]{\mathbb{#1}}
%Оформление кода
\let\ds\displaystyle
\lstset{frame=tb,
	language=C++,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
\newenvironment{myindentpar}[1]%
{\begin{list}{}%
		{\setlength{\leftmargin}{#1}}%
		\item[]
	}
	{\end{list}}
\newcommand{\image}[2] { \begin{figure}[h!] \centering	\includegraphics[scale=#2]{#1}  \end{figure} }

\begin{document}

\section{Декартово дерево}

Это бинарное дерево, в каждой вершине хранятся два значения: ключ $ k $ и приоритет $ p $.

С одной стороны это дерево поиска по ключу, и с другой -- куча по приоритету

Хотим научиться строить такую вещь, если нам задан набор пар:

$ (k_1, p_1), (k_2, p_2), \ldots , (k_n, p_n) $

Не очевидный вопрос: почему декартово дерево вообще существует?

\textit{Лемма (теорема о существовании)}

$ \forall (k_1, p_1), \ldots , (k_n, p_n) $ декартово дерево $ \exists $ и единственно (при условии, что нет одинаковых пар).

\textit{Доказательство}

Разместим все пары на плоскости:

<рис. 1 (с плоскостью и точками) от смаля>

Докажем конструктивно. Возьмем вершину (точку) с максимальным приоритетом (самую верхнюю). После этого поделим вертикальной чертой пространство на две части. Смысл этого действия очевиден -- вершины левого поддерева находятся слева, вершины правого поддерева находятся справа. Повторим процедуру для обоих частей, если они не пусты.

Это дерево поиска по построению, и куча (тоже по построению())

Тонкие моменты: одинаковые приоритеты (лучше бы не надо, но можно доопределить и брать с самым меньшим/большим ключом), одинаковые ключи (легко доопределить, относя точки, лежащие на вертикальной прямой раздела, влево или вправо)

\bigskip

Пока что очевидно, как строить за квадрат.

\textit{Эффективное построение}

Шаг 1: Сортировка по ключам $ \bigo(n \log n) $

Шаг 2: Имеем последовательность $ (k_1, p_1), \ldots , (k_n, p_n) $, причем $ k_{i + 1} \geqslant k_i \geqslant k_{i - 1} $. Будем по этой последовательности строить декартово дерево в онлайне -- будем по очереди добавлять вершины в дерамиду, т.е. всегда добавлять самую правую вершину. 

Первые две итерации очевидны (дерево из одной и из двух вершин). Научимся запихивать в произвольную дерамиду вершину, причем не абы какую, а самую правую.

<рис. 2 (с деревьями)>

Поэтому нам достаточно рассмотреть путь до самой правой вершины, и найти место (по приоритетам), куда надо вставить -- сохраняем свойство кучи. При этом остаток правого пути надо подвесить как левое поддерево (чтобы новая вершина стала самой правой) -- сохраняем свойство дерева поиска.

Как это эффективно делать?

Пусть $ v_1, \ldots , v_k $ -- это вершины самого правого пути. На любом шаге мы ищем $ v_i $ и $ v_{i + 1}  \colon  p(v_i) \geqslant p(u) > p(v_{i+1}) $
Если искать вершину от корня, то получим квадрат.

И тут \textbf{ВНЕЗАПНО}: если искать вершину с конца, то получим $ \bigo(n) $!!! (разумеется, для этого нужно будет поддерживать указатель на самую правую вершину)

Но в общем-то логично. Интуиция такая: наше переподвешивание в левое дерево укорачивает время поиска для следующих итераций. Действительно, если мы поднимались мало, то и хорошо. Если же мы поднимались долго, то мы повернем большую часть пути, и тем самым укоротим самый правый путь.

Более формально докажем это через амортизационный анализ. Пусть $ \Phi = \# $ вершин в правом пути. Пусть мы прошли $ t $ вершин, тогда амортизационная стоимость $ \acute{c} = \underset{c}{(t + 1)} \underset{\Delta \Phi }{-(t - 1)} = 2 $. 

\bigskip

Научимся делать операции с деревом.

1. $ Split (k) $ -- $ \bigo(h) $

<рис. 3 со сплитами>

На выходе получаем два дерева $ T_1, T_2 $ таких, что: $ key(T_1) < k \leqslant key(T_2) $. Опишем эту процедуру рекурсивно: посмотрим на корень. Если $ k < key(root) $, тогда распилим левое поддерево $ T_1, T_2 = Split (root.left) $, а затем вернем $ T_1 $ и склеенное $ T_2 $ и все правое поддерево и корень $ T: T.left = T_2 $. Обратный случай рассматривается аналогично.

2. $ Merge (T_1, T_2) $, причем $ \forall v_i \in T_1, v_2 \in T_2 \colon key(v_1) < key(v_2) $ -- $ \bigo(h) $

<рис. 4 с мерджами>

Рассмотрим корень второго дерево. Пусть его приоритет больше, чем приоритет корня первого дерева. Тогда это -- корень смердженного дерева. Ясно и то, что его правый сын никуда не денется. А вот левым сыном станет результат мерджа старого левого сына и первого дерева. Более формально:
%%Оформить как код!
$if p(T_2.root) > p(T_1.root) then
	T_2.left = Merge (T_1, T_2.left)
	return T_2
else 
	T_1.right = Merge(T_1.right, T_2)
	return T_1$
	
3. $ Insert (T, (k, p)) $.

Сначала сплитнем по ключу: $ T_1, T_2 = Split (T, k) $.

Затем добавляем вершину в правое поддерево и мерджим полученное: $ Merge (T_1, Merge ( (k, p) T_2 )) $

4. $ Remove (T, k) $

Сплитаем по ключу: $ T_1, T_2 = Split (T, k) $
Неожиданный сплит: $ T_3, T_4 = Split (T2, k + 1) $
Итого получили, что все ключи $ k $ лежат в $ T_3 $, осталось вернуть все кроме $ T_3 $: $ return Merge (T_1, T_4) $. 

Идея: вершины на правой ветке можно поддерживать в стеке. 

\bigskip

Если приоритеты фиксированы, то ничего поделать с высотой не поделать, она получиться такой, какой получится. Но если нам разрешил задавать приоритеты как-то произвольно, то мы можем что-нибудь соптимайзить. Например, можно выбирать приоритеты рандомно -- получим \textit{дучу} ($ treap $), она же дерамида. 

\textit{Лемма}. Матож высоты дучи есть $ \bigo(\log n) $. 

\textit{Доказательство.} Идея: предположим, что все приоритеты различны. Тогда мы знаем, что результирующая дерамида -- единственна. Значит, в доказательстве можем использовать любой алгоритм, даже неэффективный за квадрат. Но тогда, если рассмотреть процесс построения дерамиды с выдачей приоритетов случайным образом, мы обнаружим, что это до боли похоже на $ Quicksort $. А про него мы знаем, что глубина его рекурсии в среднем $ \bigo(\log n) $. Но глубина рекурсии быстросорта -- это как раз высота дерамиды. Победа!

\bigskip

Дерамида по неявному ключу.

Замечание: знание ключа необходимо только в операции $ Split $. Значит, нам могут дать набор приоритетов, сказать, что они уже упорядочены, и попросить по ним построить дерево. Жизненный пример: пусть мы хотим поддерживать номер по порядку каждого элемента во множестве, и уметь эффективно добавлять/удалять элементы из множества. Ясно, что в таком случае не можем выдать в начале суррогатные ключи, т.к. при удалении нужно будет переписать ключи во всем дереве. 

Ну давайте тогда поддерживать в каждой вершине размер дерева, корнем которого она является. Значит, посмотрев на левое поддерево, узнаем количество элементов меньше, а на правое -- количество элементов больше. 

Осталось научиться поддерживать это при сплитах и мерджах, что делается очевидно. 

Таким образом, научились делать своего рода "массив" с операциями за $ \bigo(\log n) $ в среднем с операциями $ Insert $, $ Delete $, $ Find $. На самом деле можно придумать еще очень много операций с логарифмическим временем работы, например, мердж двух массивов, вырезание подмассива, реверс массива, и даже запросы на подотрезках (максимум, сумма). 
\end{document}