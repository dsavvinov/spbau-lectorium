Человек набирает в браузере vk.com, где-то есть сервер, который отдает данные. Что посередине?

  Система адресации - IPv4. Четыре числа, разделенных точкой, каждое от 0 о 255. 
  Бывают специально зарезервированные подсети:
  		192.168.*.*
  		10.*.*.*
  		172 ....
  		127.*.*.*
  Айпишники бывают двух видов - "серые" и "белые".
  IPv4 - мало. Откуда получить белый айпишник? Купить у провайдера. Откуда у него интернет? Покупает у более крупного, и т.д.
  Откуда берет досутп в интернет самый крупный провайдер? Есть т.н. точки доступа - специальные места физического подключения в сеть интернет. 
  Эти точки имеют свои отдельно зарезервированные айпи адреса. Эти айпишники сейчас формально принадлежат компании INTERNIC, и контрольный пакет
  акций принадлежит США. 
  Эти точки связаны друг с другом т.н. магистральными сетями. Эти сети принадлежат формально частным компаниям (в России - Вымпелком, Ростелеком, Раннет и т.д.). Все эти компании, однако, находятся в государственном контроле.

Но допустим, есть еще один человек, который сидит рядом. Как к нему отправить данные напрямую? Как вообще узнать,
находится ли хост в одной подсети? Для этого используется маска подсети - маскируемые биты чужого айпишника совпадают 
с нашим айпишником, то мы в одной подсети. Тогда мы можем бахнуть пакет для этого хоста напрямую* (для wi-fi это не совсем правда, но не важно)

Ок, как мы отправляем пакеты наружу (не в нашу сеть)? Для этого нам нужно знать адрес нашего роута. Откуда это мы знаем? На самом деле, у каждого хоста
в сети прописано не только IP и маска подсети, но еще и адрес шлюза Gateway (NB: шлюз удобно представлять как два куска, одна торчит в нашу локальную сеть, другая торчит во внешнюю сеть).

Кто выдает эти значения? Можно вбить руками, а можно спросить у роутера. Откуда роутер знает? Чуть позже.

Однако человек вбивает в браузере не циферки, а какие-то буквы. Поэтому существует DNS-сервера, которые преобразуют доменные имена в айпишники.
Таким образом, на компьютер к IP/маске/шлюзу добавлется адрес DNS-сервер. DNS-сервера образуют иерархию. Каждый DNS-сервер хранит список вышестоящих DNS-серверов, и так до 12 корневых днс-серверов. Кроме-того, он обычно знает список зон, за которые он отвечает, т.е. список нижестоящих днс-серверов.

Пример: есть домен ioffe.ru. У него есть свой днс-сервер, и он знает адреса низлежащих днс-серверов, например, днс-сервера зоны school.ioffe.ru. 

Запросы бывают рекурсивные и нерекурсивные. Рекурсивный - просто поднимаемся вверх/спускаемся вниз до нужного домена. Плюс: все адреса в цепочке узнают адрес домена и могут его закешировать. Нерекурсивный - днс-сервер просто говорит, что не знает такого домена, и выдает адрес вышестоящего сервера, а клиент уже сам разбиарется. Плюс: меньше нагрузка на днс-сервера.

Что делать, если хотим новый домен первого уровня? Можно пойти к тем же INTERNIC и купить за немыслимое количество бабла.
Что, если хотем сделать домен в каком-нибудь уже существующей зоне, например, .ru. Нужно пойти к регистратору этой зоны и заплатить ему!

	Что с почтой? Пусть хотим отправить письмо на foo@bar.net . Но если спросить у ДНС-сервера про bar.net, то узнаем про *сайт* bar.net!! 
	Поэтому ДНС-сервера хранят записи *разных типов*. 
		Записи типа "A" - записи про сайты (про bar.net). 
		Запись типа "MX" - про почтовый сервер, обрабатывающий письма на домен bar.net. 
		Запись типа "NS" - про ДНС-сервер, знающий про bar.net

Ок, пусть мы отправили что-то серверу. Серверу надо ответить.

Проблема №1. Куда отправлять ответ? Очевидно, на айпишник 192.168.1.3 отвечать нельзя, т.к. подсети сменились сто раз.

Проблема №2. Окей, пусть даже КАК-ТО знаем куда отвечать. Но у нас на ПК дофига приложений, которые общаются с сетью. Как специфицировать, какому именно приложению отвечать?

Ответ №2. Добавляется еще порт, и пара (айпишник, порт) в каком-то смысле идентифицирует приложение*, общающееся с сетью (это тоже не совсем правда, т.к. это скорее индентификатор соединения, т.к. одно приложение может иметь много таких пар. В другую сторону нельзя, у одной пары не может быть несколько приложений)

=================

Стек протоколов.

1. Application layer - HTTP/SMTP/FTP. 
2. Transport layer - TCP/UDP. Здесь вылазят порты получателя/отправителя. Откуда беруется порты получателя? Есть соответствие протокол уровня приложений -> порт (например)
3. Net layer - IP, ICMP, IGMP. Здесь вылазит айпишники получателя/отправителя.
4. Link (physicall) layer - Ethernet/802.11/Token Ring/DSL/PPP. Здесь вылазят MAC-адреса. 

	Зачем иметь стек протоколов? Потому что когда мы программируем, мы не хотим знать (да нам и неважно), как именно будет передаваться наш пакет - по вай-фаю, ethernet, или почтовыми голубями. Поэтому мы все группируем это в physical layer. После этого, мы, конечно, хотим как-то однозначно* (хотя бы как-то) адресоваться, поэтому над этим вырастает net layer. 
	Ясно дело, что наверху должен быть application layer. 
	Посередине же сидит непонятный transport layer. Этот уровень нужен для удобства и возможности настроить различные протоколы с различными гарантиями над протоколом IP или любого другого с сетевого уровня.

Откуда мы берем MAC-адрес получателя на уровне 4? 
Вариант 1. Послать всем! Был такой протокол, зовется ARP (RARP). Он просто берет и отправляет широковещательный пакет со своим МАК-адресом всем (с МАК-адресом получателя ffff:ffff). Поскольку пакет широковещательный, все его получают, разорачивают и смотрят на айпишник получателя. Если это наш, то все ок, отвечаем пакетом с нашим МАК-адресом - о чудо, два собеседника узнали МАК-адреса друг друга. Если не наш, выкидываем.
Система дурная, т.к. очень не секурная. Компьютер злоумышленника просто программирует сетевой уровень так, чтобы он на любой пакет отвечал: "Да, это я." И он начнет слушать весь траффик в сети.

1. Делаем запрос к vk.com по HTTP
2. Спускаем на транспортный уровнь, дописывая порт.
3. Пытаемся узнать айпишник.
		3.1. Если еще не знаем, то формируем новый запрос уровня application к ДНС-серверу
		3.2. Получаем, спускаем на линк-уровень.
4. Нужно написать мак-адрес. 
		4.1. Если в моей сети, то все изи.
		4.2. Иначе офк нельзя броадкастить всем. ПОэтому отсылаем пакет нашему шлюзу, при этом айпишник пишем получателя, а мак-адрес шлюза.
		4.3. Маршрутизатор понимает, что этот пакет был адресован не ему, и пересылает этот адрес дальше, вписывая мак-адрес другого маршрутизатора.

	Как устроен маршрутизатор? У него есть табличка следующего состава IP | Net | Gate | Metric (эмпирическая оценка того, насколько выгодно пользоваться этим маршрутом). Его спрашивают - отправь пакет по такому-то адресу. 

Казалось бы, уф, все ок. НО! Помним проблему №1 - у нас в пакете написан наш локальный адрес, и про него никто ничего не понмиает во внешней сети. Поэтому используется адрес NAT:
1. Приходит пакет к точке доступа.
2. Она разворачивает пакет. Понимает, что адрес не наш - нужно его форвардить.
3. Тогда точка доступа меняет айпишник. Но этого было бы недостаточно - если бы это было так, то точка доступа бы офигела, когда на нее посыпались бы ответы - хрен пойми, кому в подсети пересылать этот ответ.
4. Поэтому, точка доступа разорачивает пакет на еще один уровень выше и переписывает порт, запоминая у себя его в специальной табличке вида "локальный клиент <-> фейковый порт". Теперь, когда ей придет ответ, он придет на фейковый порт, и маршрутизатор будет знать, какому локальному клиенту переадресовывать этот пакет.

Маршрутизаторы бывают L1/L2/L3-switch - по уровню стека протоколов до которого он будет разворачивать пакет. Например, L1 разворачивает пакет до Application-layer и смотрит, куда лезет приложение и может, например, применять политики и ограничения.

Был еще раньше L4-switch, который вообще не разворчаивал пакет. Он назывался хабом, и делал простую вещь - принимал пакет на каком-то порте и броадкастил его во все другие порты. Это офк плохо, и таким больше не пользуются. 
Соврменные т.н. хабы получают пакеты пакеты линк-уровня. Про каждый порт они составляют список макадресов, которые достижимы из него. Пакет приходит, хаб просто смотрит, в какой порт это надо послать и пересылает туда. Если не вышло, то броадкастит. Важно заметить, что это не маршрутизатор в полном смысле, т.к. он все-таки не занимается маршрутизацией (он не составляет метрики, например), и у него вообще нет футпринта в сети (нет айпишника).

Современные маршрутизаторы умеют программироваться. В частности, введено понятие WLAN. Каждому порту приписана метка, которая содержит число 0..255 -- номер WLAN'а, либо пачке из до 8 WLAN'ов. Таким образом, можно объединить несколько физически разделенных сетей в одну логичскую, или наоборот (изолировать часть компов для секурности).

NB. DNS - протокол уровня приложений!