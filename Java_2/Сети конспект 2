Мультиплескирование - процесс заворчаивание пакета информации в доп. заголовки, вылазящие на разных уровнях стека протоколов.
Демультиплексирование - обратный процесс.

- Протокол DHCP - dynamic host configuration protocol -
Нужен для того, чтобы хост, подсоединившись в неизвестную сеть, получил из нее сетевую маску/IP/шлюз.
Это протокол уровня Application.
Но как мы можем работать на уровне Application, если у нас даже IP нет?
Для этого придуманы дефолтные адреса. Компьютер когда включается, ему сразу выдается дефолтный айпишник. 
Как теперь отослать пакет, ведь маршрутизатор может прибить наш пакет?
Можно предупредить маршрутизатор о зарезервированных айпишниках. А можно просто броадкастить с айпишником из всех нулей. Все хосты его дропнут, 
т.к. у них не совпадет порт (за дхцп зарезервирован определенный порт, который больше никому нельзя брать), а днс-сервер примет его и выплюнет обратно конфигурацию. Конфигурацию он обратно тоже броадкастит, только теперь левые хосты будут понимаь, что пакет предназначается не для них по мак-адресу.

- Протокол TCP -
Как выглядит IP-пакет?
1. Заголовок - 20 байт.
	a. Версия - 4 бита
	b. Длина заголовка - 4 бита, и это количество байт деленное на 4. Вместе с опциями
	c. TOS - 8 бит - нафиг не нужная хрень. Когда с ее помощью типа хотели делать хинты маршрутизатору. Сейчас это часто игнорится, т.к. маршрутизаторы 	лучше знают
	d. Длина данных - 16 бит. 

	e. ID - 16 бит - номер IP-пакета. Зачем? Во-первых, любой компьютер сейчас детектирует петли, когда два маршрутизатора почему-то начинают пересылать пакет друг другу (из-за баги настройка). Во-вторых, это позволяет работать TCP (см. ниже).
	f. Reserved - 16 бит.

	g. TTL - 8 бит - Каждый раз когда пакет проходит через устройства L1/L2/L3 уровня (не L4!) из этого поля вычитается 1. Если TTL = 0, пакет дальше не пересылается.
	h. Protocol - 8 бит - транспортного уровня. 
	i. CRC - 16 бит (только заголовка).

	j. IP отправителя - 4 байта
	k. IP получателя - 4 байта
2. Опции - неизвестная длина.
3. Данные.
4. Хвост

Итак, TCP - это протокол, который устанавливает СОЕДИНЕНИЕ. Что это за СОЕДИНЕНИЕ? Это значит, что после его установки, у нас в фоновом режиме шлются пакеты: например, keep-alive. Также TCP сам нумерует пакеты, причем нумерует последовательно. Т.е. если мы получили пакет 9, потом 11, то мы говорим, что 
мы потеряли 10ый, не принимаю 11, сообщаю об этом и жду пока не пришлют 10ый. Но это конечно очень неудобно и долго, поэтому существует понятия "окна". Т.е.
мы сейчас принимаем пакеты от 8 до 15ого, и мы готовы принимать их в разном порядке и с пропусками. Но пока нам не пришлют все это окно, дальше сдвигаться мы не будем - нам присылают 16, а мы говорим: нет уж, перепошли ВСЕ (полностью!) окно. Почему все? Потому что гладиолус.

Что гарантирует TCP? Не так уж много. Мы или знаем, что окно передано успешно, но про текущее окно мы не знаем ничего. 

Кроме того, пакеты уровня TCP могут быть довольно большие (больше МБ). Тогда они самим протоколом TCP пилятся на куски и отсылаются по порядку, собираются на другом конце, и во всю эту радость еще иногда пихают служебные пакеты. 
Какую нужно задачу решать принимающей стороне? Нужно главное собрать все в правильном порядке. Для этого пакеты упорядочиваются по возрастанию ID, разворачиваются и передаются на уровень выше. Там они конкатенируются и проверяется, что вышло что-то разумное.

Проблема: пусть мы открыли два соеднения с одним и тем же хостом и передали по каждому соеднению по одному пакету уровня TCP. Каждый из пакетов нарезался на куски, обернулся в IP. И мы начинаем это отсылать.
Принимающая сторона принимает эти куски, принимает допустим IP пакет с заголовком TCP-пакета. Разворачиваем, там написан порт, мы понимаем, какому соединению предназначен этот пакет. Принмиаем следующий пакет, а он не из заголовка а уже из тела TCP пакета. Порта там нет, какому соединению отдавать эти данные? Непонятно. Поэтому в жизни для кусков TCP-пакетов дописывается еще обрезанный заголовок.


- Протокол ICMP - 
Хорошо бы как-то узнавать, что передаваемый пакет когда-то умер. Для этого есть протокол ICMP сетевого уровня. Его цель - сообщать о бедах и несчатьях в сетях.
Как это примерно работает? Когда к нам приходит пакет с TTL = 0, мы его дальше не передаем, но вместо этого отсылаем обратно ICMP пакет, внутрь которого вложен ЗАГОЛОВОК потерянного IP-пакета.
У ICMP пакета есть свой TTL, но когда ICMP умирает, обратно ничего не отсылают.
Еще там есть два значения - тип и код. Тип означает ситуацию, а код объясняет причину, почему такая ситуация возникла. Например тип 3 = не удалось доставить пакет.

ICMP можно использовать еще для разных вещей. Например, для пинга, или для узнавания маски (для этого есть специальный тип. Зачем? Затем)
Еще можно синхронизировать время.


- Динамическая маршрутизация -
Есть куча маршрутизаторов, соединенная между собой в некоторую сеть, представляющую собой граф. И теперь мы хотим построить на этом всем динамическую маршрутизацию, т.е. чтобы у каждого маршрутизатора появилась пресловутая табличка, которая будет говорить какому из его соседей пересылать пакет так, чтобы в итоге пакет дошел до адресата, и желательно быстро.

Протокол OSPF. 