# Верификатор JVM

JVM перед запуском байт-кода проверяет программу на корректность.

Верификатор следует спеке JVM консервативно. Это означает, что имеет место некоторое вложение - множество программ, которые могут быть сгенерены `javac`'ом, вкладываются во множество программ, которые верифицирует верификатор, а они, в свою очередь, вкладываются во множество всех программ, которые удовлетворяют спеке JVM.

Заметим, что может быть два подхода к верификации программ: мы можем лишь проверять, что внешняя информация, данная нам, консистента, либо же мы **можем перепроверять, что нам не наврали в посылках**. На примере типов это означает, что мы можем или поверить, что типы в байт-коде написаны честно, или же мы можем попытаться вывести типы самостоятельно и сравнить с тем, что нам написали. Но в JVM выводить типы тяжело, поэтому в основном занимаются вторым.

Что еще проверяет верификатор?
  1. Что исключения не образуют циклы. О чем это? Ну мы когда пишем на Java, мы пишем `try { ... } catch ... `, т.е. блок `catch` ровно после `try`. Но в байткоде обработчик исключения - это просто четверка `(начало адресов в try, конец адресов в try, тип исключения, адрес catch-блока)`. Разумеется, не все четверки корректны, и, более того, некоторые из гипотетически корректных четверок отвергаются верификатором (в частности, если адрес catch-блока стоит раньше диапазона try). Это делается для того, чтобы JVM было проще рассуждать о коде, т.к. все блоки, где время рабоыт программы недетерминированно (циклы, рекурсии, и т.д.) сложны для анализа.

  2. Провера байтовых магических номеров в class-файлах. (`0xCAFEBABE`)

  3. Проверка корректности стековых операций

  4. Проверка сигнатур вызываемых методов

Верификатору можно предоставлять определенные хинты. 
