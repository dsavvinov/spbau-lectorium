Итак, у нас есть гипотеза поколений, в которую мы верим. Как нам это заиспользовать?

Пусть мы даже как-то про каждый объект помним, он молодой или старый. Все равно, у нас вот запускается сборка мусора - какой нам толк от поколений, мы же все равно будем обходить весь граф, а нам этого не хочется.
Тогда давайте сделаем бит-сет на все ячейки памяти, и будем выставлять бит, если на эту ячейку памяти кто-то ссылается.
Но нам не хочется сохранять все подряд ссылки в этот бит-сет - хочется только отмечать ссылки из олд-гена в young-gen. Для этого используются барьеры чтения и записи. Они замечают, что если сохранена в поле ссылка из young-gen в young-gen или из old-gen в old-gen, то ничего делать не надо - а вот если из old-gen в young-gen, то нужно записать в битик нашего бит-сета.

Нужны еще для чего-то, но я не понял.

Теперь про остановку мира. Она должна происходить в неокторый момент, когда состояние программы консистентно. Что значить консистентность в этом смысле? Это означает, что есть возможность выяснить местонахождение всех объектов. Т.е. нужно уметь ввести программу в такое состояние, и потом вывести из него.

Существует два способа остановки мира:

1. Кооперативный.
2. Примитивный (насильственный).

Как можно примитивно придумать остановку мира? Ну в самом наивном способе, можно просто везде напихать проверок на какой-нибудь булевский флажок, который будет выставляться при остановке, и потом джамп куда-то в остановщик. Это, конечно не очень здорово, т.к. и замедляется все, и оптимизации перестают работать.

Поэтому в хотспоте используется немного другой подход - везде вставляется специальная jvm-инструкция, которая читает из вполне определенного участка памяти. Когда нужно остановить мир, права на этот участок памяти выставляются особенными, и любое чтение из него вызывает прерывание, которое отправит в обработчик прерывания, который будет понимать про остановку мира.
