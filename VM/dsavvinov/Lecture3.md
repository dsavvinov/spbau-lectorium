Сборка мусора и другие.

Когда переменная подлежит сборке мусора, т.е. когда она "не нужна"? Когда она больше не может быть использована программой.

Почему в Java используется такая сборка мусора? Чтобы программисту было удобней работать с динамическими объектами.

Откуда начинается проверка достижимости в Java? Понятно дело, стек. Еще интересный вопрос со статическими полями. Казалось бы, хочется сказать, что любое статическое поле тоже входит в корневой набор GC. Но тогда все, на что ссылается статическое поле, никогда мы не очистилось, вне зависимости от того, что произошло с классом (а классы могут подгружаться и выгружаться). Поэтому возникла концепция Classloader'ов. Classloader держит в себе ссылки на загруженные им классы.
Существует системный класслоадер, который живет все время жизни программы и никогда не вычищается. +, мы можем создавать свои classloader'ы, управляя с их помощью временной загрузкой каких-то классов.

Итак, GC обходит весь этот граф достижимых объектов, называя их все достижимыми. Все остальные - по факту недостижимы, но как об этом узнать GC? И вообще нужно ли ему знать об этом? 

1. Да, знать ему нужно, т.к. есть концепция финализации - мы не можем просто "забыть" об объекте и когда-нибудь перетереть его. Нужно именно явно сказать, что вот сейчас мы тебя будем удалять, и вызвать финализатор.

2. Знать еще нужно и потому, что есть 4 типа ссылок.
	Hard reference - Обычная ссылка, продолжщающая отношение "достижимости"
	Soft reference - Hint, что этот объект можно будет выкинуть, если память кончится. Т.е. эта ссылка продолжает отношение "достижимости" если памяти достаточно 
	Weak reference - Никогда не продолжает отношение "достижимости"
	Phantom reference - Эзотерика, для реализации очередей финализации

3. Как узнать? Просто обойти всю память, построить множество всех объектов, построить множество всех достижимых объектов, вычесть их первого второе и получим недостижимые. На практике все, конечно, умнее, но это уже оптимизации.

Метрика производительности сборщика мусора - скорость, с которой мы можем создавать объекты.

Generation Hypothesis: большинство объектов умирают молодыми. Т.е. распределение времен жизней объектов это не гауссиана, а что-то в духе пуассоновского распределения.

Какие бывают коллекторы?

NB. Существуют приближенные (консервативные) сборщики мусора. Они точно оставляют в живых все живые объекты, и, может быть, некоторый мусор. Это не очень хорошо, т.к. мы используем нашу память менее эффективно, но не смертельно.
Например, сборщик мусора Боэма (в C). Он просто если видит целое число, попадающее в диапазон адресов хипа, то считает это ссылкой.

Коллекторы HotSpot'а:

1. Mark Sweep Compact Collector. Три фазы сборщика мусора: обход графа объектов, Sweep-Compact (две фазы) - живые объекты перемещаются в один непрерывный участок памяти.

2. Parallel Collector. Тот же самый последовательный, только работает параллельно.

3. Incremental Collector. Работает параллельно с программой, делая маленькие Stop the World.

4. Сборщик с гарантиями реального времени.

5. "Garbage first". Развивает идею гипотезы поколений, разбивая хип на некоторые регионы предсказуемого размера и пытается собирать регионы, про которые он верит, что там мусор. 

Нет в HotSpot:
1. Подсчет ссылок. 
	+ Не надо делать Stop World.
	+ Arguably Просто писать. 
