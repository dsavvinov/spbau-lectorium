# Транслятор С2

**Цель** -- создать транслятор, который оптимизирует очень хорошо, но ценой очень сложной архитектуры и технологий на стороне транслятора.

Пути оптимизации

1. Эвристики "здравого смысла":
  - Обработка исключений -- наверное редко.
  - Инлайнить наверное нужно короткие часто используемые функции, например геоттеры и сеттеры.
2. Традиционный сбор статистики рантайма

**IR** C2-компилятора -- это SSA-форма, поверх CFG. Получается эдакий Data Flow Analysis. Это развязывает нам руки в плане оптимизаций, поскольку мы теперь больше знаем о наблюдаемых side-effect'ах и вольны сильней менять код, главное чтобы порожденный код сохранял side-effect'ы.

Как потом этот высокоуровневый IR транслируется в низкоуровневый? У транслятора каждая операция низкоуровневого IR имеет свой вес и свои эффекты. Задача транслятора -- набрать операций так, чтобы они делали семантически то же самое, что и высокоуровневый IR, и при этом весили поменьше.
Затем запускается Peephole Optimization -- херобобина, которая смотрить на несколько локальных инструкций, стоящих рядом, и пытается ужать их в более краткий код (пример: загрузить что-то в регистр, добавить 1, выгрузить обратно == `add` )

Что еще можно делать?

- Вот мы видим горячий метод. Мы можем начать долго и мучительно его компилировать, а потом зато быстро выполнять. Но можно поставить его в очередь на компиляцию параллельно, а пока он компилируется - интерпретировать.

- Inlining

- DCE -- очевидно, имея Data Flow Graph

- Range Check Elimination -- доказываем, что чеки на границы массива не нужны.

- Escape Analysis - доказываем, что ссылка на объект никуда не убегает. Inlining очень помогает Escape Analysis -- представим, что есть у нас метод `getLog`, который возвращает строку, потом мы в ней допустим чекам подстроку и возвращаем `true`/`false`. Не заинлайнив функцию, мы не можем знать, что ссылка на лог-строку не утекает, и вынуждены честно аллоцировать строку в хипе. А вот если заинлайнить, то мы знаем, что это своего рода локальная переменная, ссылка на которую не утекает, поэтому мы можем например ее на стеке выделить или еще как-нибудь круче.

- Instruction Scheduling.

> Как реализован `vtable` в языках с множественным наследованием? Объект хранит несколько указателей на базовые классы, и в зависимости от конкретного надтипа передается нужный указатель.
