# Динамическая трансляция

Будем говорить про JIT!

## JIT - как работает

- Основная мысль - JIT не обязателен, но хочется. Поэтому основное требвание - чтобы он был прозрачен.
- JIT может работать весьма недетрминированно.

Задача JIT'а - *не оптимизировать код*, а порождать машинный код, которому можно передавать управление из программы.

Первый в мире JIT, например, просто транслировал все, и потому был никому нафиг не нужен.

Когда мы хотим компилировать JIT или ahead of time?

- Ahead of time снимает оверхед на компиляцию во время исполнения,

- Ahead of time позволяет больше времени потратить на компиляцию и оптимизацию,

- JIT - как бы позволяет делать оптимизации, которые невозможны в статике, за счет *набора статистики*.

- JIT - например, позволяет резолвить виртуальные вызовы в динамике(деполиморфизация). Это удобно, т.к. виртуальные вызовы неудобны для конвейера процесса.
  Например, создали мы вот хеш-таблицу стрингов. В этом куске кода hashCode() будет дергаться миллион раз, а hashCode() - это вообще-то виртуальный вызов, который, как мы только что узнали, ломает нахер конвейер. Поэтому JIT берет и проставляет тип этих объектах, потому что он знает тип.
  Важно отметить, что в этом случае оптимизация будет произведена *исключительно* основываясь на *поведении* кода (можно считать, что JIT вообще не видел тип хеш-мапы)

- JIT - позволяет не делать оптимизации редко исполняемого кода.

Поскольку большинство JIT-оптимизаций спкулятивны, иногда JVM нужно уметь фоллбекаться, если предположение, в рамках которого была сделана оптимизация, оказалось неверным.
Этот механизм называется **деоптимизацией**.

Деоптимизировать на границе метода легко - мы просто если что вставляем переход не на оптимизированную реализацию метода, а на неоптимизированную (в жизни это чаще всего значит, что мы не передаем управление в траснлированный код, а продолжаем его интерпретировать в лоб)

Работает это примерно так: метод хранит указатель на транслированный машинный код. Это наша оптимизация, и она была сделана в рамках некоторых предположений. Эти предположения где-то хранятся (для простоты можно считать, что прямо там рядом с указателем и хранится). Когда мы вызываем метод, мы можем перепроверить, корректны ли предположения, и если да - то вызывать оптимизированный код, а если нет - то фоллбекнуться на обычное исполнени.

## JIT - как писать

*Конкретная интерпретация* - видим инструкцию, ее исполняем.
*Абстрактная интерпретация* - видим инструкцию, эмиттим код, который семантически ей эквиваленен, исполняем его.

Чтобы написать JIT, нужно научиться просто транслировать кусочки исходного кода в кусочки машинного кода. Вот и все :)

Вопрос, почему же JIT работает лучше, чем обычный построчный интерпретатор? Казалось бы, что тот, что этот берут JVM-инструкцию, ищут ее маш-код counterpart и исполняют его.
Ответ:
  - JIT оптимизирует накладные расходы на разбор инструкции, но это сколько-то спички, т.к. разбор VM-инструкций простой
  - А вот не спички - это непрямые переходы. Интерпретатор постоянно делает какие-то условные переходы хер пойми куда (на машкоды, соответствующие jvm-инструкциям), а куски поджиттеного кода исполняются блоками подряд, и конвейеру от этого становится очень хорошо.

**IR** - intermediate representation. Это то, как интерпретатор представляет исполняемый код. Например, AST.

Последнее время очень модно IR через SSA (single static assignment) - в каждую переменную результат пишется один раз.

Оптимизации, которые бывают:

- Dead coad elimination
- Loop fusion
- Loop inversion
- Compile-time expression
- Inlining
- Locks elimination
