## Не фон-нейманновские архитектуры

При манипуляции кодом как данными (так делает, например, JIT) на некоторых архитектурах (например, ARM, Sparc) нужно соблюдать некоторую осторожность. В частности, там разделены кеши инструкций и данных, и если мы передаем управление в только что погенеренный нами код, то мы можем зафакапиться. Поэтому нужно сбрасывать кеши перед переходом в джит-код!

## Подпрыгивания со временем

Откуда компьютер может взять время? Например, пытаться высчитать прошедшее время через количество тактов процессора. Но есть проблемы:

  1. Не учитывается многоядерность, поэтому при перепланировании программы могло прыгать время просто так.
  2. Не учитывается power management, который изменяет частоту.

Долгое время это было большой проблемой. Например, в Линуксе была глобальная переменная, которая символизировала время ОС, и она инкрементилась по прерыванию время от времени во время scheduling'а.

В итоге все свелось к тому, что в x86 (и потом и в другие) запилили отдельный хардварный модуль, который какой-то матерью считает в себе точное время, и потом можно иногда почитать оттуда время.

## Профилировка

# Эмуляция и виртуализация

## Сложности

1. Производительность.
  - Исполнение инструкций
  - Работа с памятью
  - IO

Что такое качественная виртуализация?
  - Эквивалентность -- виртуализация не меняет семантику и максимальна (со скидкой на потребление ресурсов) прозрачна для пользователя

Критерий Попека-Голдберга:
  - все чувствительные инструкции являются привелигированными инструкциями.
  - Привелигированные инструкции являются статистически редкими.
