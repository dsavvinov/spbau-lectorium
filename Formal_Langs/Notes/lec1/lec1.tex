\section{Детерминированные конечные автоматы (ДКА)}

Пусть $ \Sigma = \{0, 1\} $, $ L = \{слова\ четной\ длины \} $.

<рисунок с маленьким примером автомата и подписанными терминами>

\underline{Опр.} \textit{Автоматом} будем называть пятерку $ A = (\Sigma, Q, q_0, T, \delta) $, где:

\begin{enumerate}
	\item $ \Sigma $ -- алфавит, любое конечное множество,
	
	\item $ Q $ -- конечное множество состояний,
	
	\item $ q_0 $ -- начальное состояние, $ q_0 \in Q $,
	
	\item $ T $ -- множество терминальных состояний, $ T \subseteq Q $,
	
	\item $ \delta $ -- таблица переходов, $ \delta \colon Q \times \Sigma \to Q $.
\end{enumerate}

\underline{Опр.} Пусть $ \hat{\delta} (q, w) = \dand{q, w = \epsilon}{\hat{\delta}(\delta(q, x), t) w=xt, x \in \Sigma} $

\underline{Опр.} Обозначим $ L(A) = \{ w \in \sigma^* \colon \hat{\delta}(q_0, w) \in T \} $ -- множество слов, которые распознаются автоматом. Будем говорить, что автомат $ A $ принимает $ L(A) $.


\bigskip


Пусть $ L = \{0*1*\} $. 

<рисунок с примером автомата с тупиковым состоянием>

\underline{Опр.} \textit{Тупиковое} состояние -- нетерминальное состояние, из которого все переходы ведут в самого себя. 


\bigskip


Пусть $ \Sigma = \{0, 1\} $, $ L = \{$ число в двочиной системе счисления и делящееся на $ 6 $ $\} $. Разряды подаются справа налево.

<рисунок с автоматом для этой херовины>

\underline{Опр.} Состояния $ p $ и $ q $ называются \textit{различимыми} если $ \exists $ слово $ w $ такое, что $ \hat{\delta}(p, w) \in T\ xor\ \hat{delta}(q, w) \in T $


\bigskip



\textbf{Алгоритм миниммизации ДКА}
Давайте искать все пары различимых состояний. 

\begin{enumerate}
	\item Изначально удалим все состояния, недостижимые из начального.
	
	\item Терминальное и нетерминальное состояния различимы, т.к. пустое слово.
	
	\item Пусть $ r $ и $ s $ -- помечены как различимые. Пусть состояния $ p $ и $ q $ таковы, что $ \delta(p, x) = r $ и $ \delta(q, x) = s $. Тогда и $ p, q $ также различимы. Соображение очень простое -- раз $ r,s $ различимы, то есть слово $ w $, которое приводит их в состояния разной терминальности. Но тогда и $ p, q $ различимы по слову $ xw $.
	
\end{enumerate}

По индукции понятно, что мы найдем \textit{только} различимые состояния. Осталось доказать, что каждая пара различимых состояний будет помечена как различимая. Ну это тоже нехитро, пусть есть некоторая пара различимых состояний $ p,q  $. Рассмотрим цепочку пар состояний, которые проходятся под воздействием слова $ w $. Последняя пара -- это терминальное и нетерминальное состояния. Значит, при работе алгоритма мы когда-то пройдем от них до $ p, q $. 

\underline{Замечание} Отношение неразличимости -- это отношение эквивалентности. 

\underline{Доказательство}

\begin{myindentpar}{0.5cm}
	Удаление недостижимых вершин = $ \bigo(E) = \bigo(|\Sigma| \cdot |Q|) = \bigo(|Q|) $
	
	Пометка начальных состояний = $ \bigo(|Q|^2) $
	
	Оценим сколько раз каждая пара могла оказаться в рассматриваемой слева в переборе. Ну это конечно $ |\Sigma| $. Но тогда всего операций: $ \bigo (|\Sigma| \cdot |Q|^2) = \bigo(|Q|^2) $.
	
\end{myindentpar}

\underline{Замечание}. Есть алгоритм Хопкрофта минимизации за $ \bigo(|Q| \log |Q|) $.


\bigskip


\subsection{Эквивалентность ДКА}

Пусть есть два автомата $ A, B $, принимающие некоторые языки $ L(A), L(B) $ соответственно. 

\underline{Замечание}. Определение различимых состояний применимо для состояний из разных автоматов.

\textbf{Алгоритм проверки эквивалентности ДКА}

\begin{enumerate}
	\item Пары $ t \notin T_A $ и $ t \in T_B $. 
	
	\item Пусть $ r $ и $ s $ -- помечены как различимые. Пусть состояния $ p $ и $ q $ таковы, что $ \delta(p, x) = r $ и $ \delta(q, x) = s $. Тогда и $ p, q $ также различимы. Соображение очень простое -- раз $ r,s $ различимы, то есть слово $ w $, которое приводит их в состояния разной терминальности. Но тогда и $ p, q $ различимы по слову $ xw $.

\end{enumerate}

Тогда $ L(A) = L(B) \Leftrightarrow $ начальное состояние $ A $ неразличимо с начальным состоянием $ B $.

Время работы: $ \bigo(|Q_A| \cdot |Q_B|) $

\bigskip

\textbf{Альтернативный алгоритм проверки эквивалентности ДКА}

Давайте минимизируем оба автомата. И потом просто пойдем параллельным обходом и будем отображать вершины первого в вершину второго. А если вдруг попытались отобразить некоторую вершину в другую, которая уже была назначена кому-то, то это беда.


\bigskip


\subsection{Правые контексты}

\underline{Опр.} Пусть $ L $ -- язык, а $ x $ -- некоторое слово (не обязательно из $ L $). Тогда правым контекстом слова $ x $ в языке $ L $ называется множество слов $ С^R_L(x) = \{ y \in \Sigma^* \colon xy \in L\} $.

\underline{Следствие.} $ x \in L \Leftrightarrow \epsilon \in C_L^R(x) $

Пусть есть некоторый ДКА

\image{./lec1/img1.png}{0.5}

Пусть состояние $ q $ достижимо из начального: $ \delta (q_0, x) = q $ и $ y \in C_L^R(x) $, тогда $ \delta(q, y) \in T $. Иными словами, $ C_L^R(x) $ -- это такой язык, который принимался бы, если бы начальным автоматом было состояние $ q $. 

Теперь пусть взяли другое $ x' $, которое тоже приводит в $ q $. Ну тогда их правые контексты совпадают: $ C_L^R(x) = C_L^R(x') $.

Таким образом, \textit{если два слова приводят нас в одинаковое состояние, то у них одинаковый правый контекст}.

\bigskip

\underline{Соображение}. Пусть есть два состояния: 

\image{./lec1/img2}{0.5}

Если у этих двух состояний контексты одинаковы, тогда они тоже неразличимы. Действительно, пусть они различимы. Тогда есть одно и то же слово $ y $, приводящее из них в состояния разной терминальности, что противоречит равенству правых контекстов.

\image{./lec1/img3}{0.5}

\bigskip

Что получили? Получили, что в минимальном ДКА:

$ C_L^R(x) = C_L^R(y) \Leftrightarrow \hat{\delta}(q_0, x) = \hat{\delta}(q_0, y) $. 

Иначе говоря, то, в какое состояние минимальный ДКА переходит под воздействием слова $ x $, однозначно определяется правым контекстом слова $ x $. Говоря еще более пафосно, каждому состоянию в минимальном ДКА соответствует некоторый правый контекст.

Таким образом, получается, что есть такое свойство языка $ L $, как мощность множества различных правых контекстов.

\bigskip

\underline{Теорема}. Множество правых языков $ L $ -- конечно $ \Leftrightarrow \exists $ ДКА $ A \colon  L(A) = L $

\underline{Доказательство.} Пусть существует автомат. Тогда его можно минимизировать и откинуть недостижимые состояния. Получим некоторый ДКА $ A' $, в котором конечно количество состояний $ \Rightarrow $ конечно количество контекстов.

В обратную сторону. Пусть есть конечное множество правых контекстов. Построим ДКА $ A $. Для каждого правого контекста заведем некоторое состояние в автомате.

\begin{itemize}
	\item Начальному состоянию будет соответствовать $ C_L^R(\epsilon) $
	
	\item Терминальным состояниям соответствуют такие правые контексты, если $ \epsilon \in C_L^R(x) $
	
	\item Переходы. \image{./lec1/img4.png}{0.5}
\end{itemize}

Почему мы построили то, что нужно? Рассмотрим некоторое $ x \in \Sigma^* $. Докажем, что $ x \in L \Leftrightarrow x $ принимается $ A $. 

Утверждается, что когда $ A $ получил слово $ y $, то $ A $ находится в состоянии, соответствующему $ C_L^R(y) $. Доказательство по простенькой индукции.

\image{./lec1/img5.png}{0.5}


\subsection{Прямое произведение автоматов}

Хотим научиться принимать язык $ L(A) \cup L(B) $. Уже научились в домашках.

\bigskip

\subsection{Динамическое программирование по ДКА}

Тут я чет залип. 
