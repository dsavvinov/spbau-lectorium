\documentclass[fleqn, 12pt]{article}
\usepackage[left=0.5in, right=0.5in, top=1in, bottom=0.5in]{geometry}
\usepackage{mathexam}
\usepackage{mathtext} 				% русские буквы в фомулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{enumerate}
\usepackage{tabularx}
%%% Дополнительная работа с математикой
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools,amsthm}
%\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{enumitem}
\usepackage{indentfirst}
\usepackage{stmaryrd}	% двойные квадратные скобки
\relpenalty=9999
\binoppenalty=9999
\newcommand{\bigslant}[2]{{\raisebox{.2em}{$#1$}\left/\raisebox{-.2em}{$#2$}\right.}}
%чудоскобки
\newcommand{\lr}[1]{\left({#1}\right)}
\newcommand{\lrl}[1]{\left\{{#1}\right\}} 
\newcommand{\lrh}[1]{\left[{#1}\right]}
%мелкие полезности
\newcommand{\eps}{\varepsilon} 
\newcommand{\ar}{\ \ \Leftrightarrow \ \ }
\newcommand{\arr}{\ \Rightarrow \ }
\newcommand{\arl}{\ \Leftarrow \ }
%многострочная формула с выравниванием по амперсантам
\newcommand{\Split}[1]{%
	\begin{equation}
	\begin{split}
	#1
	\notag
	\end{split}
	\end{equation}
}
%системы уравнений
\newcommand{\dand}[2]{\left\{\begin{aligned}&#1\\&#2\\\end{aligned}\right.}
\newcommand{\dor}[2]{\left[\begin{aligned}&#1\\&#2\\\end{aligned}\right.}
\newcommand{\ans}[1]{\left\{\begin{aligned}#1\end{aligned}\right.}
\newcommand{\ors}[1]{\left[\begin{aligned}#1\end{aligned}\right.}	
\newcommand{\bigo}{\mathcal{O}}
\newcommand{\mb}[1]{\mathbb{#1}}
%Оформление кода
\let\ds\displaystyle
\lstset{frame=tb,
	language=C++,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
\newenvironment{myindentpar}[1]%
{\begin{list}{}%
		{\setlength{\leftmargin}{#1}}%
		\item[]
	}
	{\end{list}}
\newcommand{\image}[2] { \begin{figure}[h!] \centering	\includegraphics[scale=#2]{#1}  \end{figure} }

\setlist[enumerate]{topsep=0pt,itemsep=-0ex,partopsep=0ex,parsep=0ex}
\setlist[itemize]{topsep=0pt,itemsep=-0ex,partopsep=0ex,parsep=0ex}

\begin{document}

\underline{Литература}. \textit{Хопкрофт, Мотвани, Ульман.} <<Введение в теорию языков, автоматов и грамматик>>.

Мы будем работать над \underline{конечным} алфавитом $ \Sigma $.

\textit{Слово} -- \underline{конечная} последовательность элементов алфавита.

\textit{Язык} -- множество слов (в том числе $ \epsilon $ -- пустое слово).

Примеры:

\begin{enumerate}
	\item Русский язык -- бесконечный! (т.к. есть прапрапра...внуки).
	
	\item $ Java $.
	
\end{enumerate} 

Проблема -- как проверить принадлежность слова языку? (т.е. как проверить, что набор каких-то символов является корректной программой на Java?). Для этого нужно проверить \textit{семантику} языка. Данный же курс будет практически полностью изучать другую сторону -- \textit{синтаксис} языка, закрывая глаза на семантику. 

Заметим, что вопрос о принадлежности слова языку можно сформулировать как так называемый <<Yes/No question>>. Поэтому в таком контексте $ Язык = Задача $. Например, можно сказать, что есть задача с ответом да/нет -- простое ли число? Но можно и сказать, что есть некоторый язык простых чисел, и эти две вещи сколько-то равносильны друг другу.

Давайте подсчитаем количество языков. Множество слов над $ \Sigma $ -- счетное. Множество языков над алфавитом $ \Sigma = 2^{\mathcal{N}}$ -- несчетное, но вот множество конечных языков над $ \Sigma $ -- счетно. 

Таким образом, множество программ на $ Java $ (множество слов над конечных языком) -- счетно. А вот задач да/нет -- несчетно. Из этого следует много интересных следствий, в частности, что задач с ответом да/нет меньше, чем программ $ Java $ (более того, их ничтожно мало). Или что невозможно для любого действительного числа написать программу, которая бы бесконечно выводила его знаки с все более увеличивающейся точностью. А чисел, для которых такое возможно, также ничтожно мало (такие числа называются вычислимыми)

\underline{Опр.} \textit{Вычислимым} называется язык, принадлежность слова которому можно проверить некоторой программой. 

Мысль: будем изучать еще более узкий класс языков, нежели вычислимые потому, что с вычислимыми языками есть проблема. Вот пусть мы его придумали, и сказали, что якобы придумали программу, которая проверяет принадлежность этому языку. Но про такие программы очень тяжело что-то доказать! (проблемы останова, все такое)



\bigskip
\hrule
\bigskip
\section{Детерминированные конечные автоматы (ДКА)}

Пусть $ \Sigma = \{0, 1\} $, $ L = \{слова\ четной\ длины \} $.

<рисунок с маленьким примером автомата и подписанными терминами>

\underline{Опр.} \textit{Автоматом} будем называть пятерку $ A = (\Sigma, Q, q_0, T, \delta) $, где:

\begin{enumerate}
	\item $ \Sigma $ -- алфавит, любое конечное множество,
	
	\item $ Q $ -- конечное множество состояний,
	
	\item $ q_0 $ -- начальное состояние, $ q_0 \in Q $,
	
	\item $ T $ -- множество терминальных состояний, $ T \subseteq Q $,
	
	\item $ \delta $ -- таблица переходов, $ \delta \colon Q \times \Sigma \to Q $.
\end{enumerate}

\underline{Опр.} Пусть $ \hat{\delta} (q, w) = \dand{q, w = \epsilon}{\hat{\delta}(\delta(q, x), t) w=xt, x \in \Sigma} $

\underline{Опр.} Обозначим $ L(A) = \{ w \in \sigma^* \colon \hat{\delta}(q_0, w) \in T \} $ -- множество слов, которые распознаются автоматом. Будем говорить, что автомат $ A $ принимает $ L(A) $.


\bigskip


Пусть $ L = \{0*1*\} $. 

<рисунок с примером автомата с тупиковым состоянием>

\underline{Опр.} \textit{Тупиковое} состояние -- нетерминальное состояние, из которого все переходы ведут в самого себя. 


\bigskip


Пусть $ \Sigma = \{0, 1\} $, $ L = \{$ число в двочиной системе счисления и делящееся на $ 6 $ $\} $. Разряды подаются справа налево.

<рисунок с автоматом для этой херовины>

\underline{Опр.} Состояния $ p $ и $ q $ называются \textit{различимыми} если $ \exists $ слово $ w $ такое, что $ \hat{\delta}(p, w) \in T\ xor\ \hat{delta}(q, w) \in T $


\bigskip



\textbf{Алгоритм миниммизации ДКА}
Давайте искать все пары различимых состояний. 

\begin{enumerate}
	\item Изначально удалим все состояния, недостижимые из начального.
	
	\item Терминальное и нетерминальное состояния различимы, т.к. пустое слово.
	
	\item Пусть $ r $ и $ s $ -- помечены как различимые. Пусть состояния $ p $ и $ q $ таковы, что $ \delta(p, x) = r $ и $ \delta(q, x) = s $. Тогда и $ p, q $ также различимы. Соображение очень простое -- раз $ r,s $ различимы, то есть слово $ w $, которое приводит их в состояния разной терминальности. Но тогда и $ p, q $ различимы по слову $ xw $.
	
\end{enumerate}

По индукции понятно, что мы найдем \textit{только} различимые состояния. Осталось доказать, что каждая пара различимых состояний будет помечена как различимая. Ну это тоже нехитро, пусть есть некоторая пара различимых состояний $ p,q  $. Рассмотрим цепочку пар состояний, которые проходятся под воздействием слова $ w $. Последняя пара -- это терминальное и нетерминальное состояния. Значит, при работе алгоритма мы когда-то пройдем от них до $ p, q $. 

\underline{Замечание} Отношение неразличимости -- это отношение эквивалентности. 

\underline{Доказательство}

\begin{myindentpar}{0.5cm}
	Удаление недостижимых вершин = $ \bigo(E) = \bigo(|\Sigma| \cdot |Q|) = \bigo(|Q|) $
	
	Пометка начальных состояний = $ \bigo(|Q|^2) $
	
	Оценим сколько раз каждая пара могла оказаться в рассматриваемой слева в переборе. Ну это конечно $ |\Sigma| $. Но тогда всего операций: $ \bigo (|\Sigma| \cdot |Q|^2) = \bigo(|Q|^2) $.
	
\end{myindentpar}

\underline{Замечание}. Есть алгоритм Хопкрофта минимизации за $ \bigo(|Q| \log |Q|) $.


\bigskip


\subsection{Эквивалентность ДКА}

Пусть есть два автомата $ A, B $, принимающие некоторые языки $ L(A), L(B) $ соответственно. 

\underline{Замечание}. Определение различимых состояний применимо для состояний из разных автоматов.

\textbf{Алгоритм проверки эквивалентности ДКА}

\begin{enumerate}
	\item Пары $ t \notin T_A $ и $ t \in T_B $. 
	
	\item Пусть $ r $ и $ s $ -- помечены как различимые. Пусть состояния $ p $ и $ q $ таковы, что $ \delta(p, x) = r $ и $ \delta(q, x) = s $. Тогда и $ p, q $ также различимы. Соображение очень простое -- раз $ r,s $ различимы, то есть слово $ w $, которое приводит их в состояния разной терминальности. Но тогда и $ p, q $ различимы по слову $ xw $.

\end{enumerate}

Тогда $ L(A) = L(B) \Leftrightarrow $ начальное состояние $ A $ неразличимо с начальным состоянием $ B $.

Время работы: $ \bigo(|Q_A| \cdot |Q_B|) $

\bigskip

\textbf{Альтернативный алгоритм проверки эквивалентности ДКА}

Давайте минимизируем оба автомата. И потом просто пойдем параллельным обходом и будем отображать вершины первого в вершину второго. А если вдруг попытались отобразить некоторую вершину в другую, которая уже была назначена кому-то, то это беда.


\bigskip


\subsection{Правые контексты}

\underline{Опр.} Пусть $ L $ -- язык, а $ x $ -- некоторое слово (не обязательно из $ L $). Тогда правым контекстом слова $ x $ в языке $ L $ называется множество слов $ С^R_L(x) = \{ y \in \Sigma^* \colon xy \in L\} $.

\underline{Следствие.} $ x \in L \Leftrightarrow \epsilon \in C_L^R(x) $

Пусть есть некоторый ДКА

\image{img1.png}{0.5}

Пусть состояние $ q $ достижимо из начального: $ \delta (q_0, x) = q $ и $ y \in C_L^R(x) $, тогда $ \delta(q, y) \in T $. Иными словами, $ C_L^R(x) $ -- это такой язык, который принимался бы, если бы начальным автоматом было состояние $ q $. 

Теперь пусть взяли другое $ x' $, которое тоже приводит в $ q $. Ну тогда их правые контексты совпадают: $ C_L^R(x) = C_L^R(x') $.

Таким образом, \textit{если два слова приводят нас в одинаковое состояние, то у них одинаковый правый контекст}.

\bigskip

\underline{Соображение}. Пусть есть два состояния: 

\image{img2}{0.5}

Если у этих двух состояний контексты одинаковы, тогда они тоже неразличимы. Действительно, пусть они различимы. Тогда есть одно и то же слово $ y $, приводящее из них в состояния разной терминальности, что противоречит равенству правых контекстов.

\image{img3}{0.5}

\bigskip

Что получили? Получили, что в минимальном ДКА:

$ C_L^R(x) = C_L^R(y) \Leftrightarrow \hat{\delta}(q_0, x) = \hat{\delta}(q_0, y) $. 

Иначе говоря, то, в какое состояние минимальный ДКА переходит под воздействием слова $ x $, однозначно определяется правым контекстом слова $ x $. Говоря еще более пафосно, каждому состоянию в минимальном ДКА соответствует некоторый правый контекст.

Таким образом, получается, что есть такое свойство языка $ L $, как мощность множества различных правых контекстов.

\bigskip

\underline{Теорема}. Множество правых языков $ L $ -- конечно $ \Leftrightarrow \exists $ ДКА $ A \colon  L(A) = L $

\underline{Доказательство.} Пусть существует автомат. Тогда его можно минимизировать и откинуть недостижимые состояния. Получим некоторый ДКА $ A' $, в котором конечно количество состояний $ \Rightarrow $ конечно количество контекстов.

В обратную сторону. Пусть есть конечное множество правых контекстов. Построим ДКА $ A $. Для каждого правого контекста заведем некоторое состояние в автомате.

\begin{itemize}
	\item Начальному состоянию будет соответствовать $ C_L^R(\epsilon) $
	
	\item Терминальным состояниям соответствуют такие правые контексты, если $ \epsilon \in C_L^R(x) $
	
	\item Переходы. \image{img4.png}{0.5}
\end{itemize}

Почему мы построили то, что нужно? Рассмотрим некоторое $ x \in \Sigma^* $. Докажем, что $ x \in L \Leftrightarrow x $ принимается $ A $. 

Утверждается, что когда $ A $ получил слово $ y $, то $ A $ находится в состоянии, соответствующему $ C_L^R(y) $. Доказательство по простенькой индукции.

%\image{img5.png}{0.5}


\subsection{Прямое произведение автоматов}

Хотим научиться принимать язык $ L(A) \cup L(B) $. Уже научились в домашках.

\bigskip

\subsection{Динамическое программирование по ДКА}

Тут я чет залип. 


\section{Недетерминированные конечные автоматы с $ \epsilon $--переходами}

Пример $ L $ -- слова, в которых последние 10 символов начинаются с нуля.

\image{image6.png}{0.5}

Будем говорить, что $ NFA$-$\epsilon$ принимает слово $ x $, если существует хотя бы один путь, переводящий $ A $ в терминальное состояние.

Следующий пример:

$ L $ -- слова, в которых последние 10 символов начинаются с нуля, или слова четное длины.

\image{img7.png}{0.5}

То есть у нас есть некоторый оракул, который нам скажет, по какому из недетерминированных переходов перейти, чтобы победить. 

\underline{Опр.} $ \epsilon $-НКА $ A = (\Sigma, Q, Q_0, T, \Delta) $ это пятерка:

\begin{itemize}
	\item $ \Sigma $ -- алфавит
	
	\item $ Q $ -- множество состояний
	
	\item $q_0$ -- начальное состояние
	
	\item $ T \subseteq F $ -- терминальные состояния
	
	\item $ \Delta \colon Q \times (\Sigma \cup \{ \epsilon \}) \to 2^\{Q\} $ -- функция переходов. Т.е. в отличии от ДФА, при переходе по символу из некоторого состояния, у нас есть целое множество вариантов (недетерминированность!)ы
\end{itemize}

\underline{Опр.} $ \epsilon $-замыканием $ E(q) $ состояния $ q \in Q $ называется множество состояний, достижимых из $ q $ только по $ \epsilon $-переходам.

\underline{Опр.} $ \epsilon $-НКА принимает слово $ a_1 \ldots a_n $, если $ \exists $ последовательность состояний $ r_0 \ldots r_n $ такая, что $ r_0 = E(q_0) $, $ \forall i \in [1; n] \lr{r_i \in E(\Delta(r_{i - 1}, a_i))} $, $ r_n \in T $

\subsection{Алгоритм детерминизации $ \epsilon $-НКА}

Пусть есть $ \epsilon $-НКА $ A = (\Sigma, Q, q_0, T, \Delta) $. Построим ДКА 

$$ B = \lr{\Sigma, 2^{Q}, E(q_0), \{ R \colon R \cap T \neq 0 \}, \delta(R, a) = \bigcup \limits_{r \in R} E\lr{\Delta\lr{r, a}}} $$

\underline{Замечание.} Разумно включать в автомат $ B $ только состояния, достижимые из начального.

\subsection{Академические регулярные выражения}

$ \emptyset $ -- $ \emptyset $
$ \epsilon $ -- $ \{ \epsilon \} $
$ a $ -- $ \{ a \} $, $ \forall a \in \Sigma $
$ (R) $ -- $ L(R) $
$ R^* $ -- $ L(R)^* $, замыкание Клини, $ L^* = \{ w_1 \ldots w_n \colon n \geqslant, \forall w_i \in L \} $
$ R_1 R_2 $ -- $ \{ ab \colon a \in L(R_1) \land b \in L(R_2) \} $
$ R_1 \mid R_2 $ -- $ L(R_1) \cup L(R_2) $

\end{document}